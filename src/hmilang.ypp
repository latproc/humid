/*
	All rights reserved. Use of this source code is governed by the
	3-clause BSD License in LICENSE.txt.
*/
%{
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <iostream>
#include <iomanip>
#include <string>
#include <sstream>
#include <boost/foreach.hpp>
#include <symboltable.h>
#include <Logger.h>

#define COMPILER_MAIN
#include "hmilang.h"

int yylex(void);

extern int yylineno;
extern int yycharno;
extern char *yytext;

int line_num = 1;   /* updated by the lexical analysis and used for error reporting */
extern int num_errors;
extern std::list<std::string>error_messages;
Value current_value;
SymbolTable properties;
std::list<Parameter> current_parameters;
std::list<std::string> current_name_list;
std::list<SymbolTable> property_stack;

static char *error_message_name = 0;
static char *timeout_message_name = 0;

Structure *current_machine;

%}

%token MODULES MODULE DEFAULTS DEFAULT
%token STATE ENTER NUMBER SEPARATOR OEXPR EEXPR OBRACE
%token EBRACE QUOTE LE LT GE GT NE EQ
%token NOT SET AND OR SQUOTE LOG FLAG
%token PROPERTY DEFINE COLLECT FROM TEST EXECUTE SPAWN RUN
%token CALL TRIM LINE OF USING MATCH IN REPLACE WITH INTERPRET
%token COMMA BEGINPROP ENDPROP PROPSEP STATEMACHINE WHEN TO RECEIVE
%token DURING WAIT WAITFOR TRANSITION TAG INC DEC BY CONCAT
%token SEND CONDITION INITSTATE IF_ ELSE ENABLE DISABLE BECOMES
%token GLOBAL GROUP OPTION LOCK UNLOCK ON RESUME AT SHUTDOWN COMMAND
%token EXPORT READONLY READWRITE WORD DOUBLEWORD STRINGTYPE
%token STATES MATCHES COMMANDS COPY EXTRACT ALL REQUIRES
%token WHERE ROUTE ANY ARE COUNT SELECT TAKE LENGTH
%token INCLUDES INCLUDE CREATE BITSET PROPERTIES ENTRIES SORT
%token ENABLED DISABLED SIZE ITEM FIRST LAST
%token COMMON BETWEEN DIFFERENCE COMBINATION CLEAR
%token LEAVE ASSIGN WITHIN PUSH MOVE ITEMS PLUGIN
%token CHANNEL IDENTIFIER VERSION SHARES MONITORS UPDATES SENDS RECEIVES
%token INTERFACE EXTENDS KEY MACHINES MATCHING NAME EXPORTS
%token CONSTRAINT IGNORE IGNORES THROTTLE tokPUBLISHER EXISTS
%token THROW CATCH ABORT RETURN ERROR ERRORS TIMEOUT
%token REPORTS STATE_CHANGES PROPERTY_CHANGES MODBUS
%token LINKED SDO LOCAL CLASS

%union {
	int iVal;
	const char *sVal;
	const char *symbol;
	const char *pVal;
	Value *val;
	Parameter *param;
};

%token <iVal> INTEGER
%token <iVal> ADDRESS
%token <symbol> SYMBOL
%token <sVal> STRINGVAL
%token <pVal> PATTERN

%left BECOMES
%left OR
%left AND
%left GE LE EQ NE LT GT
%left '+' '-' '|'
%left '*' '/' '%' '&' '^'
%nonassoc NOT
%nonassoc UMINUS
%nonassoc '~'
%left IFX
%left IFELSE

%type <val> value
%type <param> parameter

%%

program:
program_section
| program program_section
;

program_section:
| machine_instantiation
| error ';'
| error '}'
;


machine_instantiation:
instantiation ';'
{
	std::cerr << std::setw(5) << yylineno << " " << "Instance of a machine:" << *current_machine << "\n";
	current_machine = NULL;
}
;

instantiation:
SYMBOL SYMBOL parameters
{
	current_machine = new Structure($1, $2);
	std::copy(current_parameters.begin(), current_parameters.end(),back_inserter(current_machine->parameters));
	current_parameters.clear();
	current_machine->setDefinitionLocation(yyfilename, yylineno);
	properties.clear();
}
| SYMBOL SYMBOL property_block parameters
{
	//deferred_instantiations.push_back(new MachineDetails($1, $2, current_parameters.end,
	//__FILE__, __LINE__, properties,
	//MachineInstance::MACHINE_INSTANCE));
	//current_machine = 0;
	current_machine = new Structure($1, $2);
	std::copy(current_parameters.begin(), current_parameters.end(),back_inserter(current_machine->parameters));
	current_parameters.clear();
	current_machine->setDefinitionLocation(yyfilename, yylineno);
	properties = property_stack.back();
	property_stack.pop_back();
	current_machine->setProperties(properties);
	properties.clear();
}
;


parameters:
parameter
| parameters COMMA parameter
;

parameter:
value {
	current_value = *$1;
	std::cerr << std::setw(5) << yylineno << " "  << "Symbol, value: " << *$1 << "\n";
	current_parameters.push_back(Parameter(*$1));
	$$ = new Parameter(*$1);
	delete $1;
}
| SYMBOL property_block {
	current_value = $1;
	properties = property_stack.back();
	property_stack.pop_back();
	std::cerr << std::setw(5) << yylineno << " "  << "Symbol, value: " << $1 << '[' << properties << "]\n";
	current_parameters.push_back(Parameter($1, properties));
	$$ = new Parameter($1, properties);
	properties.clear();
}
| {}
;

property_block:
'(' properties ')'
{
	std::cerr << "properties " << properties << "\n";
	property_stack.push_back(properties);
	properties.clear();
}
;

properties:
property
| properties COMMA property
;

property:
SYMBOL PROPSEP value
{
	std::cerr << "property: " << $1 << " = " << *$3 << "\n";
	properties.add($1, *$3);
	delete $3;
}
| SYMBOL {
	std::cerr << "property: " << $1 << " = 0\n";
	properties.add($1, 0);
}
;

value:
INTEGER   {
	$$ = new Value($1);
}
| STRINGVAL {
	$$ = new Value($1, Value::t_string);
}
| SYMBOL {
	$$ = new Value($1);
}

%%
void yyerror(const char *str)
{
	std::stringstream ss;
	ss << "## - Error: " << yyfilename << ":" << yylineno << ": " << str << " at token: " << yytext;
	error_messages.push_back(ss.str());
	std::cerr << ss.str() << "\n";
	num_errors++;
}

